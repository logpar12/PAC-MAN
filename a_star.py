from graph import *
import numpy as np
from queue import PriorityQueue
from application import *

# Return path generated by a_star

# Red Blob--------------------------------------------------------------------------------------------------------------
Location = TypeVar('Location')
GridLocation = Tuple[int, int]

def a_star(self, start, target):
    grid = [[0 for x in range(28)] for x in range(30)]
    for cell in self.app.walls:
        if cell.x < 28 and cell.y < 30:
            grid[int(cell.y)][int(cell.x)] = 1

    queue = [start]
    path = []
    visited = []
    while queue:
        current = queue[0]
        queue.remove(queue[0])
        visited.append(current)
        if current == target:
            break
        else:
            neighbours = [[0, -1], [1, 0], [0, 1], [-1, 0]]
            for neighbour in neighbours:
                if neighbour[0] + current[0] >= 0 and neighbour[0] + current[0] < len(grid[0]):
                    if neighbour[1] + current[1] >= 0 and neighbour[1] + current[1] < len(grid):
                        next_cell = [neighbour[0] + current[0], neighbour[1] + current[1]]
                        if next_cell not in visited:
                            if grid[next_cell[1]][next_cell[0]] != 1:
                                queue.append(next_cell)
                                path.append({"Current": current, "Next": next_cell})
    shortest = [target]
    while target != start:
        for step in path:
            if step["Next"] == target:
                target = step["Current"]
                shortest.insert(0, step["Current"])
    return shortest


# Medium website--------------------------------------------------------------------------------------------------------
def heuristic_med(a, b):
    return abs(a.position[0] - b.position[0]) + abs(a.position[1] - b.position[1])


def return_path(current_node, maze):
    path = []
    no_rows, no_columns = np.shape(maze)

    result = [[-1 for i in range(no_columns)] for j in range(no_rows)]

    current = current_node
    while current is not None:
        path.append(current.position)
        current = current.parent

    path = path[::-1]
    print("Path: ", path[1])
    start_value = 0

    for i in range(len(path)):
        result[path[i][0]][path[i][1]] = start_value
        start_value += 1

    return result


def a_star_med(maze, cost, start, end):
    # Create start and end nodes
    start_node = medium_Node(None, tuple(start))
    start_node.g = start_node.h = start_node.f = 0
    end_node = medium_Node(None, tuple(end))
    end_node.g = end_node.h = end_node.f = 0

    # Create list to keep track of visited nodes and yet_to_visit nodes
    # Used to find the lowest cost node
    yet_to_visit_list = []
    visited_list = []
    yet_to_visit_list.append(start_node)

    # Stop conditions in case of to-infinity issue
    outer_iterations = 0
    max_iterations = (len(maze) // 2) ** 10

    # Search movement
    move = [
        [-1, 0],  # Up
        [0, -1],  # left
        [1, 0],  # Down
        [0, 1]  # Right
    ]

    # Num rows and cols
    no_rows, no_columns = np.shape(maze)

    # Loop until end is found
    while len(yet_to_visit_list) > 0:
        outer_iterations += 1

        current_node = yet_to_visit_list[0]
        current_index = 0

        for index, item in enumerate(yet_to_visit_list):
            if item.f < current_node.f:
                current_node = item
                current_index = index

        if outer_iterations > max_iterations:
            print("Outer: ", outer_iterations)
            return return_path(current_node, maze)

        yet_to_visit_list.pop(current_index)
        visited_list.append(current_node)

        if current_node == end_node:
            print("Current_Node: ", current_node)
            return return_path(current_node, maze)

        children = []
        for new_position in move:
            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])

            if (node_position[0] > (no_rows - 1) or
                    node_position[0] < 0 or
                    node_position[1] > (no_columns - 1) or
                    node_position[1] < 0):
                continue
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            new_node = medium_Node(current_node, node_position)

            children.append(new_node)

            # Loop through children nodes
            for child in children:

                if len([visited_child for visited_child in visited_list if visited_child == child]) > 0:
                    continue

                child.g = current_node.g + cost
                child.h = heuristic_med(child, end_node)
                child.f = child.g = child.h

                if len([i for i in yet_to_visit_list if child == i and child.g > i.g]) > 0:
                    continue

                yet_to_visit_list.append(child)


